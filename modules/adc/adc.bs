import type {float, integer} from "../../bs-utils"

code`
#include <string.h>
#include <stdbool.h>

#include "soc/soc_caps.h"
#include "esp_adc/adc_continuous.h"

#define CONVERSION_UNIT_SIZE 256
`

code`
esp_err_t init_adc(adc_continuous_handle_t *out_handle, int32_t channel, int32_t unit, int32_t sample_freq, int32_t atten) {
    esp_err_t err = ESP_OK;
    adc_continuous_handle_t handle = NULL;
    adc_continuous_handle_cfg_t adc_config = {
        .max_store_buf_size = CONVERSION_UNIT_SIZE,
        .conv_frame_size = CONVERSION_UNIT_SIZE * 2,
    };
    err = adc_continuous_new_handle(&adc_config, &handle);
    if (err != ESP_OK) {
        return err;
    }
    adc_continuous_config_t dig_cfg = {
        .sample_freq_hz = (uint32_t)sample_freq,
        .conv_mode = ADC_CONV_SINGLE_UNIT_1,
        .format = ADC_DIGI_OUTPUT_FORMAT_TYPE1,
    };

    adc_digi_pattern_config_t adc_pattern[1] = {0};
    dig_cfg.pattern_num = 1;
    adc_pattern[0].atten = (adc_atten_t)atten;
    adc_pattern[0].channel = (uint8_t)channel;
    adc_pattern[0].unit = (uint8_t)unit;
    adc_pattern[0].bit_width = SOC_ADC_DIGI_MAX_BITWIDTH;

    dig_cfg.adc_pattern = adc_pattern;
    err = adc_continuous_config(handle, &dig_cfg);
    if (err != ESP_OK) {
        return err;
    }
    memcpy(out_handle, &handle, sizeof(adc_continuous_handle_t));
    return ESP_OK;
}
`

code`
static bool IRAM_ATTR call_cb_function(adc_continuous_handle_t handle, const adc_continuous_evt_data_t *edata, void* arg) {
    ((void (*)(value_t))gc_function_object_ptr((value_t)arg, 0))(get_obj_property((value_t)arg, 2));
    return true;
}
`

export class ADC {
    handle: Uint8Array;
    channel: integer;
    unit: integer;
    sampleFreq: integer;
    atten: integer;
    isActive: boolean;
    onConversionDone: ()=>void;

    constructor(channel: integer, unit: integer, sampleFreqHz: integer, attenuation: float) {
        this.unit = unit;
        this.channel = channel;

        // check sampleFreq
        code`
    if (SOC_ADC_SAMPLE_FREQ_THRES_HIGH < _sampleFreqHz) {
        runtime_error("** ADC module error: sampleFreq is larger than maxmum number of sample freq");
    }
    if (SOC_ADC_SAMPLE_FREQ_THRES_LOW > _sampleFreqHz) {
        runtime_error("** ADC module error: sampleFreq is smaller than minimum number of sample freq");
    }
        `
        this.sampleFreq = sampleFreqHz;

        // check attenuation
        let atten = -1;
        code`
    if (_attenuation == 0.0) {
        _atten = ADC_ATTEN_DB_0;
    } else if (_attenuation == 2.5) {
        _atten = ADC_ATTEN_DB_2_5;
    } else if (_attenuation == 6.0) {
        _atten = ADC_ATTEN_DB_6;
    } else if (_attenuation == 12) {
        _atten = ADC_ATTEN_DB_12;
    } else {
        runtime_error("** ADC module error: the specified attenuation is not available. Available attenuations are 0, 2.5, 6, 12, 11");
    }
        `
        this.atten = atten;

        let handleSize = 0;
        code`_handleSize = sizeof(adc_continuous_handle_t);`
        this.isActive = false;
        this.handle = new Uint8Array(handleSize, 0);
        this.onConversionDone = () => {};
    }

    activate():integer {
        let handle = this.handle;
        const channel = this.channel;
        const unit = this.unit;
        const sampleFreq = this.sampleFreq;
        const atten = this.atten; 
        code`
    value_t _handle = func_rootset.values[1];
    adc_continuous_handle_t* handle_ptr = (adc_continuous_handle_t*)&(value_to_ptr(_handle))->body[2];
    esp_err_t err = init_adc(handle_ptr, _channel, _unit, _sampleFreq, _atten);
    if (err != ESP_OK) {
        return esp_err_to_adc_int(err);
    }
        `
        this.handle = handle;
        this.isActive = true;
        return ADC_SUCCESS;
    }

    inActivate():integer {
        let handle = this.handle;
        code`
    value_t _handle = func_rootset.values[1];
    adc_continuous_handle_t* handle_ptr = (adc_continuous_handle_t*)&(value_to_ptr(_handle))->body[2];
    esp_err_t err = ESP_OK;
    err = adc_continuous_stop(*handle_ptr);
    if (err != ESP_OK) {
        return esp_err_to_adc_int(err);
    }
    err = adc_continuous_deinit(*handle_ptr);
    if (err != ESP_OK) {
        return esp_err_to_adc_int(err);
    }
        `
        this.isActive = false;
        return ADC_SUCCESS;
    }

    startRecording():integer {
        let handle = this.handle;
        code`
    value_t _handle = func_rootset.values[1];
    adc_continuous_handle_t* handle_ptr = (adc_continuous_handle_t*)&(value_to_ptr(_handle))->body[2];
    esp_err_t err = adc_continuous_start(*handle_ptr);
    if (err != ESP_OK) {
        return esp_err_to_adc_int(err);
    }
        `
        return ADC_SUCCESS;
    }

    stopRecording():integer {
        let handle = this.handle;
        code`
    value_t _handle = func_rootset.values[1];
    adc_continuous_handle_t* handle_ptr = (adc_continuous_handle_t*)&(value_to_ptr(_handle))->body[2];
    esp_err_t err = adc_continuous_stop(*handle_ptr);
    if (err != ESP_OK) {
        return esp_err_to_adc_int(err);
    }
        `
        return ADC_SUCCESS;
    }

    setConversionDoneCallback(cb:() => void):integer {
        let handle = this.handle;
        code`
    value_t _handle = func_rootset.values[2];
    adc_continuous_handle_t* handle_ptr = (adc_continuous_handle_t*)&(value_to_ptr(_handle))->body[2];
    adc_continuous_evt_cbs_t cbs = {
        .on_conv_done = call_cb_function,
    };
    esp_err_t err = adc_continuous_register_event_callbacks(*handle_ptr, &cbs, (void*)_cb);
    if (err != ESP_OK) {
        return esp_err_to_adc_int(err);
    }
        `
        this.onConversionDone = cb;
        return ADC_SUCCESS;
    }

    readConversionResult(): Uint8Array {
        let handle = this.handle;
        let resultSize = 0;
        code`_resultSize = CONVERSION_UNIT_SIZE`;
        let result = new Uint8Array(resultSize, 0);
        code`
    value_t _handle = func_rootset.values[1];
    value_t _result = func_rootset.values[2];
    uint8_t *result_ptr = (uint8_t*)&(value_to_ptr(_result))->body[2];;
    uint32_t out_length = 0;
    adc_continuous_handle_t* handle_ptr = (adc_continuous_handle_t*)&(value_to_ptr(_handle))->body[2];
    adc_continuous_read(*handle_ptr, result_ptr, CONVERSION_UNIT_SIZE, &out_length, 0);
        `
        return result;
    }
}


export const ADC_SUCCESS = 0;
export const ADC_FAIL = 1;
code`
int32_t esp_err_to_adc_int(esp_err_t err) {
    if (err == ESP_OK) {
        return _000005ADC_SUCCESS;
    } else {
        return _000005ADC_FAIL;
    }
}
`